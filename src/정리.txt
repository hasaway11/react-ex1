1. 전통적인 JS 방식
ㆍ개발자가 id, class 등을 이용해 DOM 요소를 직접 선택
ㆍ값이 바뀌면 직접 DOM을 수정
ㆍ값과 화면 상태를 개발자가 직접 일일이 추적해야 함

2. React의 동작 방식
ㆍReact는 상태(state) 기반으로 화면을 관리
ㆍ개발자는 UI가 상태에 따라 어떻게 보여야 하는지만 정의
ㆍ상태가 바뀌면 React가 자동으로 화면 갱신을 담당

3. Virtual DOM
ㆍ상태가 변경되면 React는 컴포넌트를 재렌더링
ㆍ컴포넌트 함수 전체가 다시 실행되어 새로운 가상 DOM을 생성해 return
ㆍ새로운 가상 DOM과 이전 가상 DOM을 비교(diffing)
ㆍ실제 DOM은 변경된 부분만 업데이트하여 성능 최적화

4. 상태
ㆍstate, props, context처럼 React 내부 메커니즘으로 관리되는 값만이 재렌더링을 트리거
ㆍ재렌더링될 때 일반 변수는 초기화되므로 값이 유지되지 않음
ㆍ상태는 React가 정한 방식(hook)을 이용해 생성해야 함

※ hook
ㆍ함수형 컴포넌트에서 React의 기능(상태 관리, 생명주기, context 등)을 사용할 수 있게 해주는 특별한 함수를 의미
ㆍ컴포넌트 최상위에서만 호출해야 함 (if, for 안에서 금지)
ㆍ반드시 React 함수(컴포넌트 or 커스텀 훅) 안에서만 사용해야 함

5. 리액트는 UI 라이브러리
ㆍ컴포넌트 렌더링
ㆍ가상 DOM 관리
ㆍ이벤트 처리
ㆍ상태 관리
ㆍ생명주기 관리


6. react bootstrap
ㆍnpm install react-bootstrap bootstrap
ㆍindex.js 또는 App.js
  import 'bootstrap/dist/css/bootstrap.min.css';

7. fiber
  - 코드
    function App() {
      const [val, setVal] = useState(1);  
      const [sal, setSal] = useState(1);  
      const valRef = useRef(1);            
      const salRef = useRef(1);    
    }

  - 리액트 내부 구조(memoizedState는 훅들의 연결 리스트 중 첫번째)
    fiber.memoizedState  ─┬─ slot[0] → { memoizedState: 1, queue: setValFn }    // useState(1)
                          ├─ slot[1] → { memoizedState: 1, queue: setSalFn }    // useState(1)
                          ├─ slot[2] → { current: 1 }                           // useRef(1)
                          └─ slot[3] → { current: 1 }                           // useRef(1)

8. 렌더링
- 리액트 컴포넌트는 순수 함수(계산만 수행)
  a. React: "화면 그릴 준비 중..."
  b. 개발자: document.title 변경!  ← 렌더링 중 외부 조작!
  c. React: "어? 렌더링 계산하는데 왜 건드려?"
- useEffect는 외부에 영향을 주는 곳 : "useEffect는 외부 시스템과 컴포넌트를 동기화하는 React Hook입니다"


9. useEffect
- 리액트는 재렌더링을 통해 UI를 출력
- 재렌더링될 때마다 JS 코드 재실행
- 초기화 또는 특정 조건에서만 JS 코드들을 실행하는 훅이 useEffect
  JSX 생성(렌더링)을 제외한 모든 작업 = 사이드 이펙트
- useEffect는 렌더링된 다음 실행되므로 적절한 guard가 필요하다

10. useCallback 의존성 배열
- 의존성 배열이 없으면 매번 새로 만들어지므로 useCallback 의미가 없다
- []로 지정하면 최초 한번만 함수를 생성한다
  handleCreate가 접근하는 값은 id, username, email, user인데 id와 user는 훅으로 최신값을 가져온다
  username, email은 함수가 생성될 때의 값이 캐시되어 있다
  useState, useRef, setState처럼 React가 안정된 참조를 보장하는 값은 의존성에 넣지 않아도 된다
- 최신의 username, email에 접근하려면 [username, email]을 사용해야 한다

useEffect : 값이 바뀌면 → 콜백 실행
useCallback : 값이 바뀌면 → 새 함수 생성
같은 문법 형태의 “의존성 배열”을 사용하지만 useEffect는 실행 조건을, useCallback은 재생성 조건을 제어한다는 점에서 개념이 다름

11. 커스텀 훅
- 상태와 관련 로직을 하나의 훅으로 묶음
- 각 컴포넌트가 독립적으로 그 훅을 사용하면 서로 다른 상태 인스턴스를 갖는다

12. zustand set 함수
- 직접 객체 전달 (정적 갱신) : 이전 상태 참조없이 새로운 값을 그대로 덮어씀
  set({ val: 1 });
- 동적 갱신 : state라는 이름은 예약어는 아니지만, 이 함수의 첫 번째 인자에 자동으로 현재 상태 객체가 전달되기 때문에 관례적으로 state라고 부름
  set((state) => ({ val: state.val + 1 }));


13. 리액트 라우터 v7
- npm install react-router-dom
  (웹사이트 npx로 설치하면 일종의 프레임워크로 설치된다)

14. SWR
- Vercel의 데이터 fetching 라이브러리
  "오래된 데이터를 먼저 보여주고, 백그라운드에서 새 데이터를 가져온다"
- 데이터패칭
  자동상태관리
    로딩, 에러, 데이터 상태를 자동으로 관리
    useState, useEffect 보일러플레이트 제거
  캐싱
    같은 키로 여러 컴포넌트에서 호출해도 한 번만 요청
  코드 간결화
  전역상태 공유(서버 상태 관리에 특화)
    // ComponentA
    const {data: user} = useSWR('/api/user', fetcher);
    // ComponentB (다른 컴포넌트)
    const {data: user} = useSWR('/api/user', fetcher); // 같은 데이터, 한 번만 요청
  Mutation 지원

15.
- SWR은 서버 상태(Server State) 관리에 특화되어 있고, 로그인 여부는 **클라이언트 상태(Client State)**에 가까움
- 왜 권장하지 않나?
    불필요한 API 호출 발생
    로그인은 "변경이 명확한" 클라이언트 상태
    성능 오버헤드(캐시 확인 → 네트워크 요청)
- 하이브리드 접근 (권장) ✅
    javascript// 1. 초기 로그인 상태는 SWR로 확인
    function App() {
      const {data: user} = useSWR('/api/auth/me', fetcher, {
        revalidateOnFocus: false,
        revalidateOnReconnect: false
      });
      
      useEffect(() => {
        if (user) {
          // Zustand에 저장
          useAuthStore.getState().setUser(user);
        }
      }, [user]);
    }

    // 2. 이후는 Zustand로 관리
    function Header() {
      const user = useAuthStore(state => state.user);
      const logout = useAuthStore(state => state.logout);
      
      return user ? <button onClick={logout}>로그아웃</button> : <Link to="/login">로그인</Link>;
    }

    // Zustand Store
    const useAuthStore = create((set) => ({
      user: null,
      setUser: (user) => set({ user }),
      logout: () => {
        api.logout();
        set({ user: null });
      }
    }));