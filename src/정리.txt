1. 전통적인 JS 방식
ㆍ개발자가 id, class 등을 이용해 DOM 요소를 직접 선택
ㆍ값이 바뀌면 직접 DOM을 수정
ㆍ값과 화면 상태를 개발자가 직접 일일이 추적해야 함

2. React의 동작 방식
ㆍReact는 상태(state) 기반으로 화면을 관리
ㆍ개발자는 UI가 상태에 따라 어떻게 보여야 하는지만 정의
ㆍ상태가 바뀌면 React가 자동으로 화면 갱신을 담당

3. Virtual DOM
ㆍ상태가 변경되면 React는 컴포넌트를 재렌더링
ㆍ컴포넌트 함수 전체가 다시 실행되어 새로운 가상 DOM을 생성해 return
ㆍ새로운 가상 DOM과 이전 가상 DOM을 비교(diffing)
ㆍ실제 DOM은 변경된 부분만 업데이트하여 성능 최적화

4. 상태
ㆍstate, props, context처럼 React 내부 메커니즘으로 관리되는 값만이 재렌더링을 트리거
ㆍ재렌더링될 때 일반 변수는 초기화되므로 값이 유지되지 않음
ㆍ상태는 React가 정한 방식(hook)을 이용해 생성해야 함

※ hook
ㆍ함수형 컴포넌트에서 React의 기능(상태 관리, 생명주기, context 등)을 사용할 수 있게 해주는 특별한 함수를 의미
ㆍ컴포넌트 최상위에서만 호출해야 함 (if, for 안에서 금지)
ㆍ반드시 React 함수(컴포넌트 or 커스텀 훅) 안에서만 사용해야 함

5. 리액트는 UI 라이브러리
ㆍ컴포넌트 렌더링
ㆍ가상 DOM 관리
ㆍ이벤트 처리
ㆍ상태 관리
ㆍ생명주기 관리


6. react bootstrap
ㆍnpm install react-bootstrap bootstrap
ㆍindex.js 또는 App.js
  import 'bootstrap/dist/css/bootstrap.min.css';

7. fiber
  - 코드
    function App() {
      const [val, setVal] = useState(1);  
      const [sal, setSal] = useState(1);  
      const valRef = useRef(1);            
      const salRef = useRef(1);    
    }

  - 리액트 내부 구조(memoizedState는 훅들의 연결 리스트 중 첫번째)
    fiber.memoizedState  ─┬─ slot[0] → { memoizedState: 1, queue: setValFn }    // useState(1)
                          ├─ slot[1] → { memoizedState: 1, queue: setSalFn }    // useState(1)
                          ├─ slot[2] → { current: 1 }                           // useRef(1)
                          └─ slot[3] → { current: 1 }                           // useRef(1)

8. 렌더링
- 리액트 컴포넌트는 순수 함수(계산만 수행)
  a. React: "화면 그릴 준비 중..."
  b. 개발자: document.title 변경!  ← 렌더링 중 외부 조작!
  c. React: "어? 렌더링 계산하는데 왜 건드려?"
- useEffect는 외부에 영향을 주는 곳 : "useEffect는 외부 시스템과 컴포넌트를 동기화하는 React Hook입니다"
